---
title: 'Marching Squares - A Primer'
description: "This blog post, titled 'Marching Squares and Quadtrees - A Primer', provides an introductory exploration into the concepts of Marching Squares and Quadtrees. It aims to demystify these complex algorithms, often used in computer graphics and game development for terrain generation and collision detection. The post breaks down the theory behind these algorithms, their applications, and how they work in tandem. It also includes practical examples and code snippets to help readers understand and implement these algorithms in their own projects. Ideal for both beginners and intermediate programmers looking to expand their knowledge in this area."
pubDate: 'Jul 27 2024'
heroImage: 'https://ucarecdn.com/7a0c1056-0ce4-48ac-890b-192598eed3ea/1marchingsquarescover.png'
tags: ["marching-squares", "quadtrees", "p5.js"]
---
import Sinx from '@blog-components/1-marching-squares/Sinx.vue'
import Grid from '@blog-components/1-marching-squares/Grid.vue'
import Grid2 from '@blog-components/1-marching-squares/Grid2.vue'
import Grid3 from '@blog-components/1-marching-squares/Grid3.vue'
import Isolines from '@blog-components/1-marching-squares/Isolines.vue'
import Accordion from '@components/Accordion.astro'


In the world of computer graphics and game development, an algorithm that comes up often is Marching Squares.
Quadtrees are also used often in the same fields, to optimize spatial queries. These two contents
are fundamental for terrain generation, collision detection, and more.

This post focuses on understanding Marching Squares, and implementing it in JavaScript using p5.js. We'll
cover on optimizing this approach using Quadtrees in a follow up blog post.

But first, let's build some motivation for why we need marching squares.

## Motivation
Say we want to draw a mathematical function, for example, $y = sin(x)$. The most intuitive way of doing so, would be
calculating the value of $y$ at each point, and connecting them with lines. Let's take a look at this approach in the animation below:

<Sinx client:visible />

You can play around with the function to see how it changes with frequency and resolution. Try doing the following things:
1. Decrease the resolution all the way down and see how it gets janky.
2. Max-out the resolution, and try increasing the frequency. You'll notice how the function gets more *hilly* and complex.
3. Turn down both of them, and see how the function doesn't even look close to the actual sin function.
4. Turn off the **show lines** option, and play around with the resolution. Notice how the number of points to each other as the resolution increases.
5. Turn on the **show axes** option, and repeat the steps above.

This changing of the graph is due to the changes in how we draw the function. As the resolution increases,
we calculate and draw more and more points, in the same space. This makes the function look more accurate.


#### The Problem
We calculate the value of $y$, as per $y = sin(x)$ at each of these points. Then, we connect them all by lines which is the graph of the function.

Let's take a look at the code for this approach.
```javascript

// The equation we are trying to draw
const equation = x => sin(x)

// How often we'll be calculating the value of y
const resolution = 100
let points = []

function setup () {
  createCanvas(400, 225)

  // Caluclate the values of x, and y
  // and store them in the points array
  for (let i = 0; i < resolution; i++) {
    let x = (width / resolution) * i
    let y = (height / 2) * sin(2 * PI * (i / resolution))
    points.push(createVector(x, y))
  }
}

function draw() {
  background(220);
  translate(0, height / 2)

  // Connect each pair of points with a line
  for (let i = 0; i < points.length - 2; i++) {
    let p1 = points[i]
    let p2 = points[i + 1]
    line(p1.x, p1.y, p2.x, p2.y)
  }
}
```

You can [install p5.js](https://p5js.org/tutorials/setting-up-your-environment/), and try out above code, or simply use the [p5.js web editor](https://editor.p5js.org/).

This approach works well to a certain extent, however it has a very serious pitfall! Can you try to guess it? Here's a hint - try to think
about a function that gives two values of $$y$$ for any given $x$!

#### The Pitfall
It turns out that this approach does not work for implicit functions. *Implicit* functions are those that do not have a direct mapping between $x$ and $y$.
Instead, they express a relationship between $x$ and $y$ in the form of an equation.


Consider the equation of a circle: $x^2 + y^2 =  r^2$ where $r$ is the radius of the circle. Let's try to draw this circle using the same approach as above.

```javascript

// The equation we are trying to draw
const equation = x => sin(x) // [!code --]
const r = 5 // [!code ++]
const equation = x => sqrt(r**2 - x**2) // [!code ++]

const resolution = 100
let points = []

function setup () {
  createCanvas(400, 225)

  for (let i = 0; i < resolution; i++) {
    let frac = i / resolution
    let x = width * frac
    let y = equation(x)
    points.push(createVector(x, y))
  }
}

function draw() {
  background(220);
  translate(0, height / 2)

  for (let i = 0; i < points.length - 2; i++) {
    let p1 = points[i]
    let p2 = points[i + 1]
    line(p1.x, p1.y, p2.x, p2.y)
  }
}
```

Replace the equation with the one above, and try running the code. You'll notice that it doesn't draw a circle, but instead a weird shape.

## Contouring
Clearly, our simplistic approach is not enough to handle *implicit* functions. We need an algorithm, which can handle if a function outputs multiple values. However, thinking about it in an analytical way actually complicates the process. Let's visualize the equation of a circle with the hopes of coming up with a better solution.

Consider the equation of a circle with radius = 5 units:  $x^2 + y^2 = 25$. Let us superimpose a grid onto this circle. Our circle will be centered at the origin $O (0, 0)$.

<Grid client:visible />

You can try playing around with the radius of the circle - it'll change in size as expected.

Now, turn on the **Show Intersections** checkbox to see where the grid lines intersect the circle and try changing the radius. If we focus solely on the squares with intersections, we start to notice some patterns. Do you see them? Try to focus on in what places the circle intersects with the squares of the grid. Sometimes the points of intersection are towards the right side of the square, and sometimes towards the left side. Sometimes, they are in the center.

Our goal is to plot this implicit curve, but as we saw in the previous $y = sin(x)$ example, computers don't work very well with plotting continuous curves. So a crude, but simple approach to discretize the curve would be to turn it into a series of line segments. How about we evaluate each intersection square, and connect the two points where the circle intersects with the square?

<Grid2 client:visible />
You can see that the circle looks quite blocky, but it's a good start. It's certainly better than our previous approach. However, there is a caveat with this approach. As the radius of the circle reduces, the blockiness becomes more pronounced. This is because the circle is being approximated by a series of line segments, and the more segments we use, the more accurate the approximation becomes. Similarly, you can imagine that as we reduce the size of the squares (i.e. increase the resolution of the grid) the blockiness becomes less pronounced. From now on, we'll be refering to these lines as *contour lines*.

While it's not critical to our purpose, if you're interested, here's the code used to calculate these intersection lines. I encourage you to read it, since it'll be beneficial in appraoching Marching Squares,


<details>
<summary>Intersection Lines Approach Code</summary>

```ts

type Point = {
  x: number
  y: number
}

// Helper function to find intersections between a circle and a square
function findCircleSquareIntersections(
  circleCenter: Point,
  radius: number,
  squareTopLeft: Point,
  squareSize: number
): Point[] {
  const intersections: Point[] = []

  // Check each edge of the square for intersections with the circle

  // Bottom edge: y = squareTopLeft.y, x from squareTopLeft.x to squareTopLeft.x + squareSize
  findCircleLineIntersections(
    circleCenter,
    radius,
    { x: squareTopLeft.x, y: squareTopLeft.y },
    { x: squareTopLeft.x + squareSize, y: squareTopLeft.y },
    intersections
  )

  // Right edge: x = squareTopLeft.x + squareSize, y from squareTopLeft.y to squareTopLeft.y + squareSize
  findCircleLineIntersections(
    circleCenter,
    radius,
    { x: squareTopLeft.x + squareSize, y: squareTopLeft.y },
    { x: squareTopLeft.x + squareSize, y: squareTopLeft.y + squareSize },
    intersections
  )

  // Top edge: y = squareTopLeft.y + squareSize, x from squareTopLeft.x to squareTopLeft.x + squareSize
  findCircleLineIntersections(
    circleCenter,
    radius,
    { x: squareTopLeft.x, y: squareTopLeft.y + squareSize },
    { x: squareTopLeft.x + squareSize, y: squareTopLeft.y + squareSize },
    intersections
  )

  // Left edge: x = squareTopLeft.x, y from squareTopLeft.y to squareTopLeft.y + squareSize
  findCircleLineIntersections(
    circleCenter,
    radius,
    { x: squareTopLeft.x, y: squareTopLeft.y },
    { x: squareTopLeft.x, y: squareTopLeft.y + squareSize },
    intersections
  )

  return intersections
}

// Find intersections between a circle and a line segment
function findCircleLineIntersections(
  circleCenter: Point,
  radius: number,
  lineStart: Point,
  lineEnd: Point,
  intersections: Point[]
): void {
  // Convert line to parametric form: point = start + t * (end - start)
  const dx = lineEnd.x - lineStart.x
  const dy = lineEnd.y - lineStart.y

  // Solve quadratic equation for t at intersection points
  const a = dx * dx + dy * dy
  const b =
    2 *
    (dx * (lineStart.x - circleCenter.x) + dy * (lineStart.y - circleCenter.y))
  const c =
    (lineStart.x - circleCenter.x) * (lineStart.x - circleCenter.x) +
    (lineStart.y - circleCenter.y) * (lineStart.y - circleCenter.y) -
    radius * radius

  const discriminant = b * b - 4 * a * c

  if (discriminant < 0) {
    // No intersections
    return
  }

  // We have intersection(s)
  const t1 = (-b + Math.sqrt(discriminant)) / (2 * a)
  const t2 = (-b - Math.sqrt(discriminant)) / (2 * a)

  // Check if intersection point is on the line segment (t in [0, 1])
  if (t1 >= 0 && t1 <= 1) {
    intersections.push({
      x: lineStart.x + t1 * dx,
      y: lineStart.y + t1 * dy,
    })
  }

  if (t2 >= 0 && t2 <= 1) {
    intersections.push({
      x: lineStart.x + t2 * dx,
      y: lineStart.y + t2 * dy,
    })
  }
}
```

</details>
<br />



This approach finds all intersections squares (in $O(n^2)$ time) and checks all four edges of each intersection square, and calculates the intersection points ($O(1)$ time). It also requires special functions to calculate the intersections between a square and circle. Now imagine if we had some other graph, maybe a complicated curve like $x\times sin(x) + y \times sin(y) = 0$ - it would be a nightmare to make a function to calculate the intersections for that. This leads us to two critical questions, which will lead us to marching squares:

1. Is there a simpler way to find which grid squares intersect?
2. Can we identify a pattern to the lines which connect the intersection points?


## Marching Squares

Now, we're just two questions away from our goal. Let's try to answer each one.

#### How to find intersections?
The approach we used in the previous section solved a quadratic equation to find the intersection points. This approach was specific to a circle, which means it won't generalize well to more complicated/different graphs. Also, each graph would require a different method of calculating the intersection points - hence, this approach of mathematically computing intersection points is not viable.

Let us shed our pechant for calculating exact intersection points, and embrace some approximation. Let's say we only want to find grid squares where the curve intersects the grid. This means that we will not consider:
1. Squares that are completely outside the curve.
2. Squares that are completely inside the curve.

For the sake of exploration, let us assign a value of **1** to every point inside the curve, and a value of **0** to every point outside the curve. Let us mark these points accordingly.

<Grid3 client:visible />

To check whether the point is inside the circle, we can simply use this piece of code:
```ts
function isPointInsideCircle(
  point: Point,
  circleCenter: Point,
  circleRadius: number
): boolean {
  const distSq =
    (point.x - circleCenter.x) * (point.x - circleCenter.x) +
    (point.y - circleCenter.y) * (point.y - circleCenter.y)
  return distSq <= circleRadius * circleRadius
}
```

This calculates the distance of the given point from the center of the circle, and checks if it is less than or equal to the radius squared. However, this can be done in a generalized way for any function. Conside some implicit function of the form $f(x, y) = c$.
$$
\therefore f(x, y) - c = 0
$$

And we can mark every point as follows:
$$
\begin{cases}
  \text{Inside} & \text{if } f(x, y) - c < 0 \\
  \text{Outside} & \text{if } f(x, y) - c > 0 \\
  \text{On} & \text{if } f(x, y) - c = 0
\end{cases}
$$

Now while we've been toying around with the math about contours for a bit, let's take a more serious look at it. This process of marking 1's and 0's "inside" or "outside" is the process of creating a scalar field. The value at each point tells us whether that point is inside or outside our shape.

The boundary of our shape — in this case, is where the value transitions from 1 to 0. This boundary is called an isoline or contour line, and it represents all points where the function equals some constant value (like the radius of our circle).

This constant value can be anything. In the real world, it is often something like temperature, pressure or elevation. For example, here's a map of contour lines representing elevation:

<img src="https://scalgo-web.imgix.net/documentation/Screenshot-from-2022-11-08-16-47-51.png?auto=compress%2Cformat&crop=focalpoint&cs=srgb&fit=crop&fp-x=0.5&fp-y=0.5&h=567&q=80&w=644&s=9666ff8020c14dbbcf786108233f34e8" style="margin: 50px auto;" />

Everyline "isoline" in this image connects places with the exact same elevation. In the same way. The elevation at any particular isoline is called the isovalue. Take a look at the visualization below - it shows a circle at different isovalues.

<Isolines client:visible />

In the general case, when we have a function $f(x, y) = c$, the constant c is called the **isovalue**. The isoline represents all the points where the function equals exactly this isovalue. For our circle example, the isoline is where $x^2 + y^2 = r^2$, so $r^2$ is our isovalue.

By tracking where values change from inside to outside across grid cells, we can approximate where the isoline passes through. This is the fundamental idea behind the Marching Squares algorithm - we're "marching" through squares in our grid, checking the configuration of inside/outside points, and drawing line segments to approximate the isoline.

What makes this approach powerful is that we're no longer limited to shapes with analytical solutions. Whether we're dealing with a circle, a complex mathematical function, or even terrain data from a height map, we can use the same algorithm to extract meaningful contours.

Let's extend this to visualize multiple isolines at different values. Rather than just binary inside/outside, we could assign a continuous range of scalar values to our field and extract multiple contour lines at different isovalues. This is exactly how topographic maps work - each contour line represents points of equal elevation.

#### How to calculate contour lines?

Marching Squares is a computer graphics algorithm used for contouring in two-dimensional scalar fields. It's often used in terrain generation in games, where it helps create more realistic and complex landscapes.

The algorithm works by dividing the terrain into a grid of squares. Each corner of a square is assigned a value based on the height of the terrain at that point. The algorithm then determines where the contour line should pass through the square, creating a more detailed and realistic terrain.

```rust
fn main () {
  println!("Hello World")
}
```

## Quadtrees

Quadtrees, on the other hand, are a tree data structure used in computer graphics and game development for spatial partitioning. They're often used for collision detection, where they help determine which objects might collide without having to check every single object.

The algorithm works by dividing the space into four quadrants. Each quadrant can be further divided into four smaller quadrants, and so on. This creates a tree structure where each node represents a quadrant of space, making it easier to check for potential collisions.

```python
# Pseudocode for Quadtrees
def quadtree(space):
    divide space into quadrants
    for each quadrant:
        if quadrant contains more than one object:
            quadtree(quadrant)
```

## Conclusion

Marching Squares and Quadtrees are powerful tools in computer graphics and game development. Understanding these algorithms and how they work together can help you create more complex and efficient games. So, start experimenting with these algorithms and see what you can create!
